import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../../../../app/theme/dimensions.dart';
import '../../../../core/widgets/loading_indicator.dart';
import '../../domain/entities/{{ snake_case_name }}_entity.dart';
import '../controllers/{{ snake_case_name }}_controller.dart';

class {{ entity_name }}FormScreen extends StatefulWidget {
  final {{ entity_name }}Entity? item;
  final bool isEditing;

  const {{ entity_name }}FormScreen({
    Key? key,
    this.item,
    this.isEditing = false,
  }) : super(key: key);

  @override
  State<{{ entity_name }}FormScreen> createState() => _{{ entity_name }}FormScreenState();
}

class _{{ entity_name }}FormScreenState extends State<{{ entity_name }}FormScreen> {
  final _formKey = GlobalKey<FormState>();
  late {{ entity_name }}Controller _controller;
  bool _isLoading = false;

  // Form field controllers
{% for field in fields %}
  late TextEditingController _{{ field.name }}Controller;
{% endfor %}

  @override
  void initState() {
    super.initState();
    _controller = Provider.of<{{ entity_name }}Controller>(context, listen: false);

    // Initialize controllers
{% for field in fields %}
{% if field.type == 'String' %}
    _{{ field.name }}Controller = TextEditingController(text: widget.item?.{{ field.name }} ?? '');
{% elif field.type == 'int' or field.type == 'double' %}
    _{{ field.name }}Controller = TextEditingController(
      text: widget.item?.{{ field.name }}?.toString() ?? '',
    );
{% elif field.type == 'bool' %}
    _{{ field.name }}Controller = TextEditingController(
      text: (widget.item?.{{ field.name }} ?? false) ? 'true' : 'false',
    );
{% elif field.type == 'DateTime' or field.type == 'DateTime?' %}
    _{{ field.name }}Controller = TextEditingController(
      text: widget.item?.{{ field.name }}?.toString().substring(0, 10) ?? '',
    );
{% else %}
    _{{ field.name }}Controller = TextEditingController(
      text: widget.item?.{{ field.name }}?.toString() ?? '',
    );
{% endif %}
{% endfor %}
  }

  @override
  void dispose() {
{% for field in fields %}
    _{{ field.name }}Controller.dispose();
{% endfor %}
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.isEditing ? 'Edit {{ entity_name }}' : 'Create {{ entity_name }}'),
      ),
      body: _isLoading
          ? const LoadingIndicator()
          : SingleChildScrollView(
              padding: const EdgeInsets.all(Dimensions.paddingM),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    _buildFormFields(),
                    const SizedBox(height: Dimensions.marginL),
                    _buildButtons(),
                  ],
                ),
              ),
            ),
    );
  }

  Widget _buildFormFields() {
    return Column(
      children: [
{% for field in fields %}
{% if field.type == 'String' %}
        TextFormField(
          controller: _{{ field.name }}Controller,
          decoration: const InputDecoration(
            labelText: '{{ field.name | capitalize }}',
            hintText: 'Enter {{ field.name }}',
          ),
          validator: {% if field.required is defined and field.required %}(value) {
            if (value == null || value.isEmpty) {
              return '{{ field.name | capitalize }} is required';
            }
            return null;
          }{% else %}null{% endif %},
        ),
{% elif field.type == 'int' %}
        TextFormField(
          controller: _{{ field.name }}Controller,
          decoration: const InputDecoration(
            labelText: '{{ field.name | capitalize }}',
            hintText: 'Enter {{ field.name }}',
          ),
          keyboardType: TextInputType.number,
          validator: {% if field.required is defined and field.required %}(value) {
            if (value == null || value.isEmpty) {
              return '{{ field.name | capitalize }} is required';
            }
            try {
              int.parse(value);
            } catch (e) {
              return 'Please enter a valid number';
            }
            return null;
          }{% else %}(value) {
            if (value != null && value.isNotEmpty) {
              try {
                int.parse(value);
              } catch (e) {
                return 'Please enter a valid number';
              }
            }
            return null;
          }{% endif %},
        ),
{% elif field.type == 'double' %}
        TextFormField(
          controller: _{{ field.name }}Controller,
          decoration: const InputDecoration(
            labelText: '{{ field.name | capitalize }}',
            hintText: 'Enter {{ field.name }}',
          ),
          keyboardType: const TextInputType.numberWithOptions(decimal: true),
          validator: {% if field.required is defined and field.required %}(value) {
            if (value == null || value.isEmpty) {
              return '{{ field.name | capitalize }} is required';
            }
            try {
              double.parse(value);
            } catch (e) {
              return 'Please enter a valid number';
            }
            return null;
          }{% else %}(value) {
            if (value != null && value.isNotEmpty) {
              try {
                double.parse(value);
              } catch (e) {
                return 'Please enter a valid number';
              }
            }
            return null;
          }{% endif %},
        ),
{% elif field.type == 'bool' %}
        SwitchListTile(
          title: const Text('{{ field.name | capitalize }}'),
          value: _{{ field.name }}Controller.text == 'true',
          onChanged: (bool value) {
            setState(() {
              _{{ field.name }}Controller.text = value ? 'true' : 'false';
            });
          },
        ),
{% elif field.type == 'DateTime' or field.type == 'DateTime?' %}
        TextFormField(
          controller: _{{ field.name }}Controller,
          decoration: InputDecoration(
            labelText: '{{ field.name | capitalize }}',
            hintText: 'YYYY-MM-DD',
            suffixIcon: IconButton(
              icon: const Icon(Icons.calendar_today),
              onPressed: () => _selectDate(context, _{{ field.name }}Controller),
            ),
          ),
          readOnly: true,
          validator: {% if field.required is defined and field.required %}(value) {
            if (value == null || value.isEmpty) {
              return '{{ field.name | capitalize }} is required';
            }
            return null;
          }{% else %}null{% endif %},
        ),
{% else %}
        TextFormField(
          controller: _{{ field.name }}Controller,
          decoration: const InputDecoration(
            labelText: '{{ field.name | capitalize }}',
            hintText: 'Enter {{ field.name }}',
          ),
          validator: {% if field.required is defined and field.required %}(value) {
            if (value == null || value.isEmpty) {
              return '{{ field.name | capitalize }} is required';
            }
            return null;
          }{% else %}null{% endif %},
        ),
{% endif %}
        const SizedBox(height: Dimensions.marginM),
{% endfor %}
      ],
    );
  }

  Widget _buildButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: const Text('Cancel'),
        ),
        const SizedBox(width: Dimensions.marginM),
        ElevatedButton(
          onPressed: _saveForm,
          child: Text(widget.isEditing ? 'Update' : 'Create'),
        ),
      ],
    );
  }

  Future<void> _selectDate(BuildContext context, TextEditingController controller) async {
    final DateTime now = DateTime.now();
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: controller.text.isNotEmpty
          ? DateTime.parse(controller.text)
          : now,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );

    if (picked != null) {
      setState(() {
        controller.text = picked.toString().substring(0, 10);
      });
    }
  }

  Future<void> _saveForm() async {
    if (_formKey.currentState!.validate()) {
      setState(() {
        _isLoading = true;
      });

      try {
        final {{ entity_name }}Entity entity;

        if (widget.isEditing && widget.item != null) {
          entity = widget.item!.copyWith(
{% for field in fields %}
{% if field.type == 'String' %}
            {{ field.name }}: _{{ field.name }}Controller.text,
{% elif field.type == 'int' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? int.parse(_{{ field.name }}Controller.text)
                : null,
{% elif field.type == 'double' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? double.parse(_{{ field.name }}Controller.text)
                : null,
{% elif field.type == 'bool' %}
            {{ field.name }}: _{{ field.name }}Controller.text == 'true',
{% elif field.type == 'DateTime' or field.type == 'DateTime?' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? DateTime.parse(_{{ field.name }}Controller.text)
                : null,
{% else %}
            {{ field.name }}: _{{ field.name }}Controller.text,
{% endif %}
{% endfor %}
          );

          await _controller.update(entity);
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('{{ entity_name }} updated successfully'),
              ),
            );
          }
        } else {
          entity = {{ entity_name }}Entity(
            id: '',  // Will be generated by the repository
{% for field in fields %}
{% if field.type == 'String' %}
            {{ field.name }}: _{{ field.name }}Controller.text,
{% elif field.type == 'int' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? int.parse(_{{ field.name }}Controller.text)
                : null,
{% elif field.type == 'double' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? double.parse(_{{ field.name }}Controller.text)
                : null,
{% elif field.type == 'bool' %}
            {{ field.name }}: _{{ field.name }}Controller.text == 'true',
{% elif field.type == 'DateTime' or field.type == 'DateTime?' %}
            {{ field.name }}: _{{ field.name }}Controller.text.isNotEmpty
                ? DateTime.parse(_{{ field.name }}Controller.text)
                : null,
{% else %}
            {{ field.name }}: _{{ field.name }}Controller.text,
{% endif %}
{% endfor %}
            createdAt: DateTime.now(),
            updatedAt: DateTime.now(),
          );

          await _controller.create(entity);
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('{{ entity_name }} created successfully'),
              ),
            );
          }
        }

        if (mounted) {
          Navigator.of(context).pop();
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Error saving {{ entity_name }}: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } finally {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
        }
      }
    }
  }
}